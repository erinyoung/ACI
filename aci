#!/usr/bin/env python3

'''
Author: Erin Young

Description:

This script will find the coverage for each amplicon in a bedfile and then graph it.

Tis masqurading as a real python program.

EXAMPLE:
aci -b input.bam -d amplicon.bed
'''

# trying to keep dependencies really low
import argparse
import os
import sys
import subprocess
import concurrent.futures
import pandas as pd
import itertools
import numpy as np
import matplotlib.pyplot as plt

import time ## for testing
# about 30 seconds per artic V3 primer on SRR13957125
# $ samtools coverage SRR13957125.sorted.bam
# #rname      startpos endpos numreads covbases coverage meandepth meanbaseq meanmapq
# MN908947.3  1        29903  1141595  29827    99.7458  5350.27   37.3      60
# 15000 - 16500

script_directory = os.path.dirname(os.path.abspath(sys.argv[0]))

version = '0.0.20230715'
samtools = script_directory + '/bin/samtools/samtools'

parser = argparse.ArgumentParser()
parser.add_argument('-b', '--bam', nargs = '+', required= True, type=str, help='(required) input bam file')
parser.add_argument('-d', '--bed', required = True, type = str, help ='(required) amplicon bedfile')
parser.add_argument('-s', '--single', action='store_true', help ='flag that specifies that reads are single-end in bam file')
parser.add_argument('-o', '--out', type=str, help='directory for results', default='aci')
parser.add_argument('-t', '--threads', type=int, help='specifies number of threads to use', default=4)
parser.add_argument('-v', '--version', help='print version and exit', action='version', version='%(prog)s ' + version)
args      = parser.parse_args()

# the function that reduces the bam file to the region in question and then gets coverage
def amplicon_depth(df, bam, region, single):
    # start_time = time.time() ## for testing
    ref        = region.split(':')[0]
    start      = int(region.split(':')[1])
    end        = int(region.split(':')[2])
    name       = region.split(':')[3]
    file_name  = os.path.basename(bam)

    # print('For ' + bam + ' region ' + region + ' checkpoint 1: ' + str(time.time() - start_time)) ## for testing
    bed1 = args.out + '/tmp.' + name + '.' + file_name + '.bed'
    bam0 = args.out + '/tmp.' + name + '.0.' + file_name
    bam1 = args.out + '/tmp.' + name + '.1.' + file_name
    bam2 = args.out + '/tmp.' + name + '.2.' + file_name
    bam3 = args.out + '/tmp.' + name + '.3.' + file_name
    bam4 = args.out + '/tmp.' + name + '.4.' + file_name

    if start <= 1:
        # print('For ' + bam + ' region ' + region + ' checkpoint 2: ' + str(time.time() - start_time)) ## for testing
        with open(bed1, mode='wt') as file:
            file.write(ref + '\t' + str(end + 1) + '\t5000000\n')
    else:
        # print('For ' + bam + ' region ' + region + ' checkpoint 3: ' + str(time.time() - start_time)) ## for testing
        with open(bed1, mode='wt') as file:
            file.write(ref + '\t' + str('0') + '\t' + str(start - 1) + '\n' + ref + '\t' + str(end + 1) + '\t5000000\n')

    # print('For ' + bam + ' region ' + region + ' checkpoint 4: ' + str(time.time() - start_time)) ## for testing
    if single:
        paired_flag = ''
    else:
        paired_flag = '-f2 '

    # running samtools
    # print('For ' + bam + ' region ' + region + ' checkpoint 5: ' + str(time.time() - start_time)) ## for testing
    os.system(samtools + ' sort -o ' + bam0 + " " + bam)
    # print('For ' + bam + ' region ' + region + ' checkpoint 6: ' + str(time.time() - start_time)) ## for testing
    if os.path.exists(bam0):
        os.system(samtools + ' index ' + bam0)
        os.system(samtools + ' view -bh ' + paired_flag + bam0 + ' ' + ref + ':' + str(start) + '-' + str(end) + ' -o ' + bam1 )
        os.remove(bam0)
        os.remove(bam0 + '.bai')
    
    # print('For ' + bam + ' region ' + region + ' checkpoint 7: ' + str(time.time() - start_time)) ## for testing
    if os.path.exists(bam1):
        os.system(samtools + ' index ' + bam1)
        os.system(samtools + ' view -bh ' + bam1 + ' -U ' + bam2 + ' -o ' + bam3 + ' -L ' + bed1 )
        os.remove(bam1)
        os.remove(bam1 + '.bai')
    
    os.remove(bed1)

    # print('For ' + bam + ' region ' + region + ' checkpoint 8: ' + str(time.time() - start_time)) ## for testing
    if os.path.exists(bam2):
        os.system(samtools + ' index ' + bam2)
        os.system(samtools + ' view -bh ' + paired_flag + bam2 + ' ' + ref + ':' + str(start) + '-' + str(end) + ' -o ' + bam4 )
        os.remove(bam2)
        os.remove(bam2 + '.bai')
        os.remove(bam3)
        
    # print('For ' + bam + ' region ' + region + ' checkpoint 9: ' + str(time.time() - start_time)) ## for testing
    if os.path.exists(bam4):
        os.system(samtools + ' index ' + bam4)
        stdout = subprocess.run([samtools, 'coverage', '--no-header', bam4, '-r', ref + ':' + str(start) + '-' + str(end)], capture_output=True, text=True, check=True)

        # print('For ' + bam + ' region ' + region + ' checkpoint 10: ' + str(time.time() - start_time)) ## for testing
        cov = float(stdout.stdout.strip().split()[6])
        os.remove(bam4)
        os.remove(bam4 + '.bai')  
    else:
        cov=0

    # print('For ' + bam + ' region ' + region + ' checkpoint 11: ' + str(time.time() - start_time)) ## for testing    
    bamindex = df.index[df['bam'] == bam]
    df.loc[bamindex, [name]] = cov

    # print('For ' + bam + ' region ' + region + ' checkpoint fin: ' + str(time.time() - start_time)) ## for testing

if not os.path.exists(args.bed):
    print('FATAL : bedfile ' + args.bed + ' does not exist. Exiting')
    exit(1)

if not os.path.exists(args.out):
    os.mkdir(args.out)

print("ACI version :\t\t"     + str(version))
print("Number of threads :\t" + str(args.threads))
print("Final directory :\t"   + str(args.out))
if args.single:
    print("Read type :\t\tSingle")
else:
    print("Read type :\t\tPaired")
print("Input bed file :\t"    + str(args.bed))
print("Input bam file(s) :\t" + ', '.join(args.bam))

##### ----- ----- ----- ----- ----- #####
##### Part 1. Amplicon depths       #####
##### ----- ----- ----- ----- ----- #####

print("Getting depth for amplicons")
pool = concurrent.futures.ThreadPoolExecutor(max_workers=args.threads)
df        = pd.DataFrame([])
df['bam'] = args.bam
regions   = []

with open(args.bed) as file:
    for line in file:
        ref=str(line.split('\t')[0])
        start=str(int(line.split('\t')[1]))
        end=str(int(line.split('\t')[2]))
        name=str(line.split('\t')[3])
        regions.append(ref + ':' + start + ':' + end + ':' + name)

for input in list(itertools.product(args.bam,regions)):
        if (args.single):
            pool.submit(amplicon_depth,df, input[0], input[1], True)
        else:
            pool.submit(amplicon_depth,df, input[0], input[1], False)

pool.shutdown(wait=True)

# writing results to a file
df.to_csv(args.out + '/amplicon_depth.csv', index=False)

# getting rid of column with all the bam names
df.drop('bam', axis=1, inplace=True)

boxplot = df.boxplot(fontsize=5, rot=90, figsize=(15,8), grid=False)
boxplot.plot()
plt.title('Primer Assessment')
boxplot.set_ylabel('meandepth')
boxplot.set_xlabel('amplicon name')
boxplot.figure.savefig(args.out + '/amplicon_depth.png', bbox_inches='tight')
plt.close()

print("Depth for amplicons is saved in " + args.out + '/amplicon_depth.csv')
print("An boxplot of these depths is at " + args.out + '/amplicon_depth.png')

##### ----- ----- ----- ----- ----- #####
##### Part 2. Genome/bam depths     #####
##### ----- ----- ----- ----- ----- #####

# now getting depth information for comparison
os.system(samtools + " depth --threads " + str(args.threads) + ' ' + ' '.join(args.bam) + " > " + args.out + "/depth.txt")

df1 = pd.read_table(args.out + "/depth.txt", header= None, delimiter= "\t")

# renaming columns (because there's no header)

bam_names = []
for bam in args.bam:
    file_name  = os.path.basename(bam)
    bam_names.append(file_name)

df1.columns = ['ref', 'pos'] + bam_names

# dividing positions into group for boxplot
df1['group'] = (df1['pos'] / 500).apply(np.floor)
df1 = df1.drop(['ref', 'pos'], axis=1)

# getting a df for graphing
df2 = df1.groupby(['group']).mean().reset_index()
df2['start'] = (df2['group'] * 500).astype(int)
df2['end']   = (df2['group'] * 500 + 499).astype(int)
df2['pos']   = df2['start'].astype('str') + "-" + df2['end'].astype('str')

# remove depth file
os.remove(args.out + "/depth.txt")

# writing results to a file
df2.to_csv(args.out + '/genome_depth.csv', index=False)

groups=df2['pos'].to_list()

# getting rid of column with all the group names
df2 = df2.drop(['group', 'pos', 'start','end'], axis=1)

# switching columns (bam files) for rows (positions)
df2 = df2.transpose()
df2.columns=groups

# creating the boxplot
boxplot2 = df2.boxplot(fontsize=5, rot=90, figsize=(15,8), grid=False)
boxplot2.plot()
plt.title('Average depth across genome')
boxplot2.set_ylabel('meandepth')
boxplot2.set_xlabel('position (start-end)')
boxplot2.figure.savefig(args.out + '/genome_depth.png', bbox_inches='tight')
plt.close()

print("Depth for the genome from the bam file is saved in " + args.out + '/genome_depth.csv')
print("An boxplot of these depths is at " + args.out + '/genome_depth.png')

print("ACI is complete! (And I hope all your primers are behaving as expected!)")
